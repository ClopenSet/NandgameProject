# 知识准备
## 布尔代数
- 布尔函数：对若干个布尔变量取值，产生一个确定的布尔输出。F(a1,a2,...)=A
### 真值表
真值表是用来展示逻辑运算结果的一种表格方法。它列出了所有可能的输入组合及其对应的输出结果。例如，一个基础的 AND 运算的真值表如下：

| A | B | A AND B |
|---|---|---------|
| 0 | 0 |    0    |
| 0 | 1 |    0    |
| 1 | 0 |    0    |
| 1 | 1 |    1    |

### 一元布尔运算和二元布尔运算
- **一元布尔运算**：这类运算只涉及一个变量，即 F(a)= A。最常见的一元布尔运算是 NOT 运算，它将输入的逻辑值反转（即，将 1 变为 0，将 0 变为 1）。例如，NOT A (通常写作 ¬A 或 A') 的真值表如下：

  | A | ¬A  |
  |---|-----|
  | 0 |  1  |
  | 1 |  0  |

- **二元布尔运算**：这类运算涉及两个变量，即F(a,b) = A。除了上面提到的 AND 运算，还包括 OR 运算和 XOR（异或）运算等。OR 运算的真值表如下：

  | A | B | A OR B |
  |---|---|--------|
  | 0 | 0 |   0    |
  | 0 | 1 |   1    |
  | 1 | 0 |   1    |
  | 1 | 1 |   1    |

  在这里，如果 A 或 B 中至少有一个为 1，那么 A OR B 的结果就为 1。
### 常见技巧
#### De Morgan 律
- **第一律**：NOT (A AND B) 等同于 (NOT A) OR (NOT B)，用符号表示为 ¬(A ∧ B) = ¬A ∨ ¬B。
- **第二律**：NOT (A OR B) 等同于 (NOT A) AND (NOT B)，用符号表示为 ¬(A ∨ B) = ¬A ∧ ¬B。

#### 消去律
- 消去律的核心在于逻辑表达式中反相器的消除。如果一个逻辑变量经过反相后，又立即被另一个反相器处理，这两个反相器就可以互相抵消，从而简化整个逻辑表达式。
- 数学上可以表述为： ¬(¬ A)= A

好的，这里是关于如何从真值表获得 CNF（合取范式）和 DNF（析取范式），以及卡诺图的基本介绍。
#### CNF 和 DNF
- CNF : 通过合取 （AND） 连接若干析取子句的布尔函数
- DNF : 通过析取 （OR） 连接若干合取子句的布尔函数

#### 如何从真值表获得 CNF 和 DNF
从真值表中提取 CNF 和 DNF 是布尔代数中一个重要的过程，主要用于简化逻辑表达式。以下是步骤：

1. **确定输出为真的行（对于 DNF）**：
   - 对于每一行输出为真的组合，记录对应的输入变量组合。
   - 对于变量为1的情况，直接写变量名；对于变量为0的情况，写该变量的否定形式。
   - 将这些变量用 AND 连接，形成一个乘积项。
   - 将所有这样的乘积项用 OR 连接，形成最终的 DNF。

2. **确定输出为假的行（对于 CNF）**：
   - 对每一行输出为假的组合，记录对应的输入变量组合。
   - 对于变量为1的情况，写该变量的否定形式；对于变量为0的情况，直接写变量名。
   - 将这些变量用 OR 连接，形成一个和项。
   - 将所有这样的和项用 AND 连接，形成最终的 CNF。

容易证明 CNF 和 DNF 必然等价于真值表

### 卡诺图
卡诺图（Karnaugh Map）是一个用于布尔函数最小化的图形工具。类似于寻找和化简DNF或CNF，故不赘述

### 布尔运算全介绍
#### 一元运算

一元运算的真值表包含两行，对应变量可以取值0或1。理论上，对于单一变量的一元运算存在 $2^2 = 4$ 种可能的运算结果。设变量为 $a$：

1. **恒定为0**：通常表示为 0或 $F$ 或 $False$。在 Verilog 中常用 `1'b0` 表示。（实际上退化为零元运算）
2. **恒定为1**：通常表示为 1或 $T$ 或 $True$。在 Verilog 中常用 `1'b1` 表示。（实际上退化为零元运算）
3. **同 $a$ 相同**：即运算结果就是 $a$ 的原值。
4. **同 $a$ 相反**：这种运算有多种表示方法：
   - **非**：在 Verilog 和 C 语言中用 `~` 表示。
   - **取反**：在数学逻辑中常用 `¬` 表示。
   - **否定**：逻辑上称为 negation，常用 `!` 表示。
   - **补**：在布尔代数中称为 补（complement），用上加横线$~ \overline a ~$表示。

#### 二元运算
二元运算涉及两个变量，并根据这两个变量的值决定结果。对于二元运算，其真值表有四行，每行代表一种可能的输入组合（即，两个变量各可以取值0或1）。因此，理论上存在 $2^4 = 16$ 种可能的运算结果。

##### 退化的六种情况
在这16种可能的运算中，有六种情况退化为更简单的零元或一元运算：
1. **恒定为0** 和 **恒定为1**：这两种运算不依赖于输入变量 $a$ 或 $b$ 的值，始终输出0或1，退化到零元运算。
2. **输出等于 $a$**、**输出等于 $b$**、**输出等于 $\neg a$**（$a$ 的逻辑非）、**输出等于 $\neg b$**（$b$ 的逻辑非）：这些运算结果仅依赖于单一输入变量的值或其逻辑非，因此可以视为退化到一元运算。

##### 非退化情况
7. **与（AND）**：
   - 符号表示为 $ a \& b $（C语言和Verilog）、$ a \wedge b $（数学）、并且逻辑学中称为合取（conjunction）。
   - 在编程中，逻辑与使用 `&&` 表示。
   - 常被描述为加法或和。

8. **或（OR）**：
   - 符号表示为 $ a | b $（C语言和Verilog）、$ a \vee b $（数学），并且逻辑学中称为析取（disjunction）。
   - 在编程中，逻辑或使用 `||` 表示。
   - 常被描述为乘法或积。

9. **与非（NAND）**：
   - 在Verilog中表示为 `a ~& b`，常用名称为 NAND。
   - 这种运算是AND运算后接一个NOT，即 $ \neg (a \wedge b) $，也用 $ \neg (a \wedge b) $。

10. **或非（NOR）**：
    - 在Verilog中表示为 `a ~| b`，常用名称为 NOR。
    - 这种运算是OR运算后接一个NOT，即 $ \neg (a \vee b) $。

11. **异或（XOR）**：
    - 表示为 `xor`、$ a \oplus b $（数学符号）或 `a ^ b`（C语言和Verilog）。
    - 异或运算是指两个操作数不同时输出真，可以通过其CNF（合取范式）和DNF（析取范式）来表达和实现。

- **析取范式（DNF）**：
  $$
  a \oplus b = (a \wedge \neg b) \vee (\neg a \wedge b)
  $$
  这表示 $ a $ 为真且 $ b $ 为假，或者 $ a $ 为假且 $ b $ 为真时，输出为真。

- **合取范式（CNF）**：
  $$
   a \oplus b = (a \vee b) \wedge (\neg a \vee \neg b)
  $$
  这表示 $ a $ 或 $ b $ 至少一个为真，且 $ a $ 或 $ b $ 至少一个为假时，输出为真。

12. **同或（XNOR）**：
    - 也称为异或非，表示为 `xnor` 或 `a ~^ b`（Verilog）。
    - 同或运算是异或运算的逻辑否定，即两个操作数相同时输出为真，其CNF和DNF也可以从XOR推导得出。

13. **蕴含（Implication）**:
    - **a 蕴含 b**：这个运算在逻辑学上非常著名。逻辑学上常表示为 $ a \rightarrow b $，这可以通过其他逻辑运算符表示为 $ \neg a \lor b $。在电路设计中，这种运算经常出现，需要熟悉这种转换：$ \neg a \lor b = a ~ NAND ~ b ~ NAND ~ a~ $。

14. **b 蕴含 a**：
    - 与第十三种相似

15. **不蕴含（Non-implication）**:
    - **a 不蕴含 b**：逻辑学上常表示为 $ a \not\rightarrow b $，这可以通过其他逻辑运算符表示为 $ a \land \neg b $。在电路中，这种运算也常见，其等效NOR电路实现为 $ a \wedge \neg b = a ~NOR~ b ~NOR~ a $。

16. **b 不蕴含 a**：
    - 与第十五种相似

#### 三元及以上运算
在逻辑代数中，除了可以退化为二元或一元运算的情形外，三元及以上的复杂运算通常是通过组合二元和一元运算来表达。不过一些运算拥有更简便的表示方式：

- **全与（AND）**：所有输入必须为真（1）时，输出为假（0）。在数学符号中，这可以表示为大的与运算符（AND），使用 LaTeX 表达式为：
$$
  \bigwedge_{i=1}^n a_i  
  
$$
其中 ($a_i$) 表示第 (i) 个输入变量。

类似的还有全异或（XNOR）和全与非（NAND）等运算


## 思想准备
### 模块化设计思想
#### 模块
模块工作类似于一个黑箱，对于每个合法的输入，它都能产生确定的行为和输出。这种设计的好处是使用者无需了解模块内部的具体实现细节，只需知道其功能即可进行使用。

#### 模块化
模块化是一种设计策略，它涉及将复杂的系统拆分成多个独立的、可以自由组合的模块。这种方法的优点在于能够创建逻辑井然有序的系统架构，便于管理和扩展。

#### 自顶向下
自顶向下的设计方法从系统的最高层次开始，逐步向下拆分成更小、更简单的组件。这种方法允许设计者先解决大的问题，再逐步细化到具体的实现细节。

#### 自底向上
与自顶向下相反，自底向上的方法从最基本的单元开始，逐步组合这些单元构建出复杂的系统。这种策略使得每个构建块都能在整合为更大系统之前进行彻底测试和优化。

#### 管道化
管道化是将一个复杂的过程分解为若干个顺序的小步骤，每个步骤处理一部分任务。这种方式可以优化性能和资源利用，特别是在数据处理和指令执行的应用中非常有效。

#### 层次
一个或几个隔断整个系统的模块构成一个层次；此层次之上和之下的模块，均需要和这个层次中的模块进行上传下达的通信。这种设计的优点在于，由于一个层次是隔断的，一个层次之上和之下的模块互不影响；不同层级的开发者可以专注于自己的领域专长，仅需考虑邻近层次的工作，而无需考虑整个复杂的整体。

### 设计与实现思想
#### 设计
设计是规划和定义系统或产品的行为和结构，不涉及具体如何构建。

#### 实现
实现是根据设计规划实际构造系统或产品的过程。

#### 标准
标准定义了某个产品或系统应当如何表现，它是希望所有相关方都能遵守的一组规则和指南。标准确保了不同实现之间的兼容性和可交换性。标准不定义具体的实现方法。

#### 设计与实现的关系
一个设计可以有多种不同的实现方式，每种实现可能在性能、效率、成本等方面有所不同，但在外部表现上应当是一致的。这种分离确保了设计的多样性和灵活性，同时降低了对最终用户的影响。

#### 设计与实现的分离
- **代码**：代码是描述设计的一种方式，它遵循特定的语法规则，以确保清晰和一致性。他并不指明具体的实现方式。
- **编译**：编译过程是将代码中的设计转换为实现。
- **编译器**：编译器是一个自动化的工具，它按照给定的设计（代码）生成具体的实现。

### 抽象

#### 定义
抽象是将若干较基本的元素（常常是具体的操作和实现细节）隐藏起来，只暴露必要的接口和行为，而构成一个更为较复杂概念的行为。

在实际中，计算机并不理解高级概念如模块、层次或文件；它仅仅按顺序执行机器代码。抽象使得开发者无需每次都处理底层的机器语言，而是可以操作更高级的构造，如文件、数据库或用户界面。例如，当我们谈论“处理一个文件”时，实际上是在引用一系列复杂的底层操作，这些操作被封装在“文件”这个抽象概念之下。

#### 控制复杂性
抽象是控制复杂性的一种重要工具。它允许我们将注意力集中在当前层次的问题上，而不是被其他层次的细节所困扰。通过定义清晰的界面和分离关注点，抽象帮助我们逐步建立起复杂的系统，每一步都建立在前一步的基础上。

抽象是现代计算机技术的基石，它通过使复杂系统的管理变得可行。而计算机世界也就是这样日积跬步而产生。
